import scipy.stats as st
import matplotlib.pyplot as plt
from pymrm.smrm import *

"""
Example taken from :
Numerical approximation of probability mass functions via the inverse discrete fourier transform. Methodology and 
Computing in Applied Probability,
16(4):1025â€“1038, 2014.

We solve an SMP problem, represented as a discrete (lattice) sMRM.
Results are compared to the original paper.
"""

# variant of the discrete weibull distribution
def discrete_wei_variant_pmf(k, q, b):
    temp1 = q ** ((k - 1) ** b) - q ** (k ** b)
    temp2 = k - np.floor(k)
    temp3 = temp2 < 1e-15
    temp4 = k == 0
    temp1[temp4] = 0
    return temp1 * temp3


# results from the original paper
paper_orig_results = np.asarray(
    [-8.16582112800508e-18, -8.81126023381286e-18, 0.02375, 0.00953224331794616, 0.0202403241962559,
     0.012579141153354,
     0.0176993647481019, 0.0136301965372228, 0.0160423738270662, 0.0138376877580659,
     0.0149135992607506, 0.0136686832188755,
     0.0140846354554204, 0.0133349595300537, 0.0134273393352838, 0.0129355678259519,
     0.0128719597164535, 0.0125168293946163,
     0.012380553676667, 0.0120999143966653, 0.0119321752406655, 0.0116939750636139, 0.0115149468876286,
     0.0113024846117531,
     0.0111218715540821, 0.0109263028885622, 0.0107486237377347, 0.010565149213248, 0.0103923774625043,
     0.0102182985911548,
     0.0100511766763188, 0.00988490082646705, 0.00972359062946208, 0.0095641184875216,
     0.00940852036917891,
     0.00925517958300661, 0.00910508653732266, 0.00895739149554068, 0.0088125618052461,
     0.00867013846508029,
     0.00853032847037889, 0.00839287304728823, 0.00825785070153139, 0.00812510622206977,
     0.00799465563429389,
     0.00786639808750548, 0.00774032002973863, 0.00761634980487251, 0.00749446057166252,
     0.00737459690067237,
     0.00725672663318482, 0.00714080380770885, 0.00702679477462976, 0.00691465945716641,
     0.00680436448883786,
     0.00669587372987762, 0.00658915486547498, 0.00648417459651774, 0.00638090194454639,
     0.00627930580482963,
     0.00617935659421832, 0.00608102499941008, 0.00598428279216683, 0.00588910218331217,
     0.00579545622052575,
     0.00570331845017122, 0.00561266310659503, 0.00552346493107081, 0.00543569925758854,
     0.00534934191254054,
     0.00526436924964288, 0.00518075809156024, 0.00509848574026458, 0.00501752994080543,
     0.00493786888017735,
     0.0048594811630761, 0.00478234580571115, 0.00470644221828249, 0.00463175019685907,
     0.0045582499098077,
     0.00448592188921017, 0.00441474701975697, 0.00434470653036415, 0.00427578198470791,
     0.00420795527330838,
     0.00414120860522955, 0.00407552450071047, 0.00401088578374181, 0.00394727557524084,
     0.00388467728631864,
     0.00382307461196064, 0.00376245152485764, 0.00370279226954235, 0.00364408135669286,
     0.00358630355767524,
     0.00352944389925045, 0.00347348765847702, 0.00341842035776746, 0.00336422776011033,
     0.00331089586443299])

# modification of the paper's algorithm (yielding more precise solutions).
paper_mod_results = np.asarray(
    [1.01188673461367e-17, 1.08530331531694e-17, 0.02, 0.0110271522677442, 0.0168535563738509,
     0.0135709969738574, 0.0152562571113129, 0.0139766835830135, 0.0143462304435285, 0.0137491918118073,
     0.0137016638361357, 0.0133420887636555, 0.0131687846499837, 0.0128978777853786, 0.0126929898658751,
     0.012460404372785, 0.0122536671012588, 0.0120416724156809, 0.0118417900216474, 0.0116435577467571,
     0.0114524838616209, 0.0112649384359224, 0.0110825643198675, 0.0109040140658615, 0.0107296900511681,
     0.0105590241485939, 0.0103920359553528, 0.0102284364027697, 0.0100681392684954,
     0.00991096515996887, 0.00975680885851674, 0.00960554106833948, 0.0094570627248551,
     0.00931127200296638, 0.00916808160211785, 0.00902740737773195, 0.00888917357797052,
     0.00875330870765649, 0.00861974690425275, 0.00848842627223674, 0.00835928906816874,
     0.00823228091735096, 0.00810735066770489, 0.00798444994971045, 0.00786353296758536,
     0.00774455621260114, 0.00762747826896542, 0.00751225960850147, 0.00739886242840616,
     0.00728725049637985, 0.00717738901962805, 0.00706924452480132, 0.00696278475326984,
     0.00685797856657715, 0.00675479586273381, 0.00665320750096895, 0.00655318523455743,
     0.00645470165041434, 0.00635773011487196, 0.0062622447248059, 0.00616822026356493,
     0.00607563216112015, 0.00598445645798111, 0.00589466977244671, 0.00580624927083048,
     0.00571917264033149, 0.00563341806426769, 0.00554896419941786, 0.00546579015525019,
     0.00538387547483997, 0.00530320011730204, 0.00522374444158338, 0.00514548919147853,
     0.00506841548174605, 0.00499250478521766, 0.00491773892080351, 0.00484410004230779,
     0.0047715706279779, 0.00470013347071883, 0.00462977166891146, 0.00456046861778012,
     0.00449220800126032, 0.0044249737843227, 0.0043587502057137, 0.00429352177107749,
     0.00422927324642727, 0.00416598965193715, 0.00410365625602879, 0.00404225856972934,
     0.0039817823412796, 0.0039222135509734, 0.00386353840621071, 0.00380574333674898,
     0.0037488149901385, 0.00369274022732871, 0.00363750611843398, 0.00358309993864789,
     0.00352950916429651, 0.00347672146902171, 0.00342472472008635])

if __name__ == "__main__":
    np.random.seed(123456)  # warn: remember to remove this

    ########################################################
    # create SMP model

    num_states, N = 2, 100
    A_matrix = np.asarray([[0, 1],
                           [0.95, 0]])
    b_vector = np.asarray([0, 0.05])
#     sampling_P_matrix = np.hstack((A_matrix, b_vector.reshape(-1, 1)))

    pmf_matrix = np.zeros((num_states, num_states, N), )
    pmf_vector = np.zeros((num_states, N), )

    points = np.arange(0, N)
    pmf_matrix[0, 1] = st.geom.pmf(points, 0.8)
    pmf_matrix[1, 0] = discrete_wei_variant_pmf(points, 0.3, 0.5)
    pmf_vector[1] = discrete_wei_variant_pmf(points, 0.5, 0.7)
    xs = np.arange(0, N)

    ######################################################

    # solve via GE (prepare then solve)
    I_AoG, h_v = prepare_ge_pmfs(A_matrix, b_vector, pmf_matrix, pmf_vector, N)
    pmfx_ge = solve_ge(I_AoG.copy(), h_v.copy(), N)

    # plot results (pmf on one graph, and errors on the other).
    fig, axs = plt.subplots(2, 1)

    axs[0].plot(xs, pmfx_ge[0, :N], label='Gaussian elimination, N=' + str(N), linewidth=5, linestyle=':',
                color='black')
    axs[0].plot(xs, paper_orig_results[:N], label='paper\'s original results', linestyle='-.', linewidth=2)
    axs[0].plot(xs, paper_mod_results[:N], label='paper\'s modified results', linestyle='-', linewidth=2)
    axs[0].set_title("Cumulated time starting from state 0 reaching state 2")
    axs[0].set_ylabel("pmf(x)")
    axs[0].set_xlabel("time")
    axs[0].legend()

    axs[1].plot(xs, paper_orig_results[:N] - pmfx_ge[0, :N], label='paper\'s original results')
    axs[1].plot(xs, paper_mod_results[:N] - pmfx_ge[0, :N], label='paper\'s modified results')
    axs[1].set_title("Difference between paper's results and naive Gaussian elimination")
    axs[1].set_ylabel("diff.")
    axs[1].set_xlabel("time")
    axs[1].legend()
    # axs[1].set_yscale('log')

    plt.show()
